{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(source,true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import{Platform}from'@unimodules/core';import path from'path-browserify';import PixelRatio from\"react-native-web/dist/exports/PixelRatio\";import URL from'url-parse';import AssetSourceResolver from\"./AssetSourceResolver\";import{manifestBaseUrl,getManifest}from\"./PlatformUtils\";var assetMapOverride=getManifest().assetMapOverride;export function selectAssetSource(meta){if(assetMapOverride&&assetMapOverride.hasOwnProperty(meta.hash)){meta=_objectSpread({},meta,{},assetMapOverride[meta.hash]);}var scale=AssetSourceResolver.pickScale(meta.scales,PixelRatio.get());var index=meta.scales.findIndex(function(s){return s===scale;});var hash=meta.fileHashes?meta.fileHashes[index]||meta.fileHashes[0]:meta.hash;var uri=meta.fileUris?meta.fileUris[index]||meta.fileUris[0]:meta.uri;if(uri){return{uri:resolveUri(uri),hash:hash};}var assetUrlOverride=getManifest().assetUrlOverride;if(assetUrlOverride){var _uri=path.join(assetUrlOverride,hash);return{uri:resolveUri(_uri),hash:hash};}var fileScale=scale===1?'':\"@\"+scale+\"x\";var fileExtension=meta.type?\".\"+encodeURIComponent(meta.type):'';var suffix=\"/\"+encodeURIComponent(meta.name)+fileScale+fileExtension+\"?platform=\"+encodeURIComponent(Platform.OS)+\"&hash=\"+encodeURIComponent(meta.hash);if(/^https?:\\/\\//.test(meta.httpServerLocation)){var _uri2=meta.httpServerLocation+suffix;return{uri:_uri2,hash:hash};}if(getManifest().developer){var baseUrl=new URL(getManifest().bundleUrl);baseUrl.set('pathname',meta.httpServerLocation+suffix);return{uri:baseUrl.href,hash:hash};}return{uri:\"https://d1wp6m56sqw74a.cloudfront.net/~assets/\"+encodeURIComponent(hash),hash:hash};}export function resolveUri(uri){if(!manifestBaseUrl){return uri;}var _ref=new URL(uri),protocol=_ref.protocol;if(protocol!==''){return uri;}var baseUrl=new URL(manifestBaseUrl);var resolvedPath=uri.startsWith('/')?uri:path.join(baseUrl.pathname,uri);baseUrl.set('pathname',resolvedPath);return baseUrl.href;}","map":{"version":3,"sources":["/home/rick/dev/cool-home/node_modules/expo-asset/build/AssetSources.js"],"names":["Platform","path","URL","AssetSourceResolver","manifestBaseUrl","getManifest","assetMapOverride","selectAssetSource","meta","hasOwnProperty","hash","scale","pickScale","scales","PixelRatio","get","index","findIndex","s","fileHashes","uri","fileUris","resolveUri","assetUrlOverride","join","fileScale","fileExtension","type","encodeURIComponent","suffix","name","OS","test","httpServerLocation","developer","baseUrl","bundleUrl","set","href","protocol","resolvedPath","startsWith","pathname"],"mappings":"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","sourcesContent":["import { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { manifestBaseUrl, getManifest } from './PlatformUtils';\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta) {\n    // Override with the asset map in manifest if available\n    if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n        meta = { ...meta, ...assetMapOverride[meta.hash] };\n    }\n    // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n    // explicitly provided URIs\n    const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n    const index = meta.scales.findIndex(s => s === scale);\n    const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n    // Allow asset processors to directly provide the URL to load\n    const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n    if (uri) {\n        return { uri: resolveUri(uri), hash };\n    }\n    // Check if the assetUrl was overridden in the manifest\n    const assetUrlOverride = getManifest().assetUrlOverride;\n    if (assetUrlOverride) {\n        const uri = path.join(assetUrlOverride, hash);\n        return { uri: resolveUri(uri), hash };\n    }\n    const fileScale = scale === 1 ? '' : `@${scale}x`;\n    const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n    const suffix = `/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}?platform=${encodeURIComponent(Platform.OS)}&hash=${encodeURIComponent(meta.hash)}`;\n    // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n    // development server or production CDN URL origin\n    if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n        const uri = meta.httpServerLocation + suffix;\n        return { uri, hash };\n    }\n    // For assets during development, we use the development server's URL origin\n    if (getManifest().developer) {\n        const baseUrl = new URL(getManifest().bundleUrl);\n        baseUrl.set('pathname', meta.httpServerLocation + suffix);\n        return { uri: baseUrl.href, hash };\n    }\n    // Production CDN URIs are based on each asset file hash\n    return {\n        uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n        hash,\n    };\n}\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri) {\n    if (!manifestBaseUrl) {\n        return uri;\n    }\n    const { protocol } = new URL(uri);\n    if (protocol !== '') {\n        return uri;\n    }\n    const baseUrl = new URL(manifestBaseUrl);\n    const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n    baseUrl.set('pathname', resolvedPath);\n    return baseUrl.href;\n}\n//# sourceMappingURL=AssetSources.js.map"]},"metadata":{},"sourceType":"module"}